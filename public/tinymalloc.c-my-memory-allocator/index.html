<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>tinymalloc.c, my memory allocator - Simone Bellavia&#39;s Web Page</title>
<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
</head>
<body>
  <header>
    <header>
    <h1>Simone Bellavia&#39;s Web Page</h1>
</header>
  </header>
  <main>
    
<article>
    <h1>tinymalloc.c, my memory allocator</h1>
    <h2 id="introduction">introduction</h2>
<p>I love C. I love low-level engineering, and I love memory management. during my summer break, I wanted to have some fun re-implementing malloc() from scratch. it&rsquo;s a classic university project.
however, as I was working on it, I realized I could do more and had a lot of fun experimenting with alternatives, studying papers, and looking at other memory allocator implementations.</p>
<p><a href="https://github.com/sibellavia/tinymalloc">that&rsquo;s how tinymalloc was born.</a></p>
<h2 id="key-features-of-tinymalloc">key features of tinymalloc</h2>
<p>in the beginning, tinymalloc provided a simple linked-list with while loops calling sbrk().
over time, the design changed profoundly and I made specific technical choices.</p>
<p><a href="https://x.com/sibellavia/status/1822283610805662053"><img src="/images/tinymalloc.c/benchmark.png" alt="my X post with tinymalloc benchmark"></a></p>
<ul>
<li>multi-arena design. i really liked it in jemalloc, and I wanted to integrate it in my implementation. tinymalloc uses a multi-arena approach where memory is divided into separate arenas. each thread is typically assigned its own arena for small and medium allocations.</li>
<li>bitmap-based allocation. after dismissing the linked-list approach I implemented an allocator that uses a bitmap to keep track of free and occupied memory blocks. I wanted an approach that could offer a good balance between allocation speed and memory overhead.</li>
<li>allocation size ranges. tinymalloc categorizes allocations into three ranges: small, medium and large:
<ul>
<li>small allocations (&lt;=64bytes) use a fast-path allocation strategy</li>
<li>medium allocations use a standard bitmap search</li>
<li>large allocations (&gt;= 4096 bytes) are handled separately, potentially using a different arena to avoid fragmentation of smaller allocation spaces.</li>
</ul>
</li>
<li>dynamic heap extension. when the existing heap space is exhausted, tinymalloc can dynamically extend the heap. this should allow the allocator to adapt to growing memory needs without requiring a fixed initial allocation.</li>
<li>thread-local optimization. hoping of having implemented it correctly lol. btw, tinymalloc uses a thread-local storage to remember each thread&rsquo;s assigned arena. I wanted it to reduce the overhead of arena selection of subsequent allocations from the same thread.</li>
</ul>
<h2 id="core-components">core components</h2>
<p>let&rsquo;s examine the fundamental building blocks. the allocator is built around a few key structures and global variables that manage the memory allocation process.</p>
<h3 id="bitmapallocator-struct">BitmapAllocator struct</h3>
<p>the very core of tinymalloc&rsquo;s allocation strategy is the BitmapAllocator structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>heap;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> heap_size;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>bitmap;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> bitmap_size;
</span></span><span style="display:flex;"><span>} BitmapAllocator;
</span></span></code></pre></div><ul>
<li><em>heap</em> is a pointer to the heap memory</li>
<li><em>heap_size</em> self-explaining</li>
<li><em>bitmap</em> is a pointer to the bitmap used for tracking allocations</li>
<li><em>bitmap_size</em> is the size of the bitmap</li>
</ul>
<h3 id="arena-struct">Arena struct</h3>
<p>represents a single allocation arena:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  BitmapAllocator allocator;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_mutex_t</span> mutex;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> allocated_blocks;
</span></span><span style="display:flex;"><span>} Arena;
</span></span></code></pre></div><p>each arena contains:</p>
<ul>
<li>a <em>BitmapAllocator</em> for managing its heap</li>
<li>a mutex for thread-safe ops</li>
<li>a count of <em>allocated_blocks</em> for load balancing</li>
</ul>
<h3 id="global-variables">Global variables</h3>
<p>tinymalloc uses several global variables to manage its state:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> Arena <span style="color:#f92672">*</span>arenas <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">// the array of arenas
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> num_arenas <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// number of arenas
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> arenas_initialized <span style="color:#f92672">=</span> false; <span style="color:#75715e">// whether the arenas have been initialized
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> next_arena_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// the index for the next arena to be assigned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pthread_mutex_t</span> malloc_mutex <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER; <span style="color:#75715e">// mutex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">pthread_mutex_t</span> arena_index_mutex <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER; <span style="color:#75715e">// mutex
</span></span></span></code></pre></div><h3 id="constants">Constants</h3>
<p>several constants define the behavior off the allocator:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define HEAP_SIZE 1048576 </span><span style="color:#75715e">// 1 MB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define BLOCK_SIZE 16     </span><span style="color:#75715e">// 16 bytes per block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define BITMAP_SIZE (HEAP_SIZE / BLOCK_SIZE / 64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SMALL_ALLOCATION_THRESHOLD (4 * BLOCK_SIZE)   </span><span style="color:#75715e">// 64 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define LARGE_ALLOCATION_THRESHOLD (256 * BLOCK_SIZE) </span><span style="color:#75715e">// 4096 bytes
</span></span></span></code></pre></div><p>so the BitmapAllocator manages individual heaps, while the Arena structure provides a layer of abstraction for multi-threaded use. the global variables and constants offer a guide to the overall behavior and limits of the allocator.</p>
<h2 id="allocation-process">allocation process</h2>
<p>the allocation process in tinymalloc involves several steps.</p>
<p>we start with an initialization check. <em>initialize_if_needed</em> function is called at the start of tinymalloc:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">initialize_if_needed</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>arenas_initialized) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">init_memory</span>()) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    arenas_initialized <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>this sets up arenas if they haven&rsquo;t been initialized.</p>
<p>the <em>select_arena</em> function chooses an arena for the allocation. it assigns each thread its own arena for small and medium allocations, and select the least used arena for large allocation. if no free blocks are found, <em>extend_heap</em> is called, increases the size of the heap and bitmap.</p>
<p>the tinymalloc function coordinates these steps:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tinymalloc</span>(<span style="color:#66d9ef">size_t</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>malloc_mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">initialize_if_needed</span>()) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>malloc_mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> <span style="color:#a6e22e">allocate_memory</span>(size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>malloc_mutex);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>the entire process manages memory allocation across multiple threads.</p>
<h2 id="deallocation-process">deallocation process</h2>
<p>the deallocation process in tinymalloc involves locating the correct arena for a given pointer and freeing the associated blocks. the <em>tinyfree</em> function coordinates the deallocation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tinyfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ptr <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>malloc_mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Arena <span style="color:#f92672">*</span>arena <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_arena_for_pointer</span>(ptr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (arena <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>malloc_mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// invalid pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (arena <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">deallocate_memory</span>(arena, ptr);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>malloc_mutex);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="potential-improvements-and-contributing">potential improvements and contributing</h2>
<p>I wrote tinymalloc entirely for fun. there are indeed some ares that could be improved.</p>
<p>the first I can identify is the global mutex for all allocations. it can become a bottleneck especially under high concurrency.</p>
<p>the second flaw is that the current arena selection mechanism for large allocations iterates through all arenas. highly inefficient as the number of arenas increases.</p>
<p>also, having a fixed <em>HEAP_SIZE</em> is slop. it may not be optimal for all use cases and it might be too small for some applications, or wasteful for others.</p>
<p>memory fragmentation. the big monster. the current allocation strategy doesn&rsquo;t do much to prevent or mitigate fragmentation. which could lead to inefficient memory use over time.</p>
<p>and more.</p>
<p>but! these issues provide a good starting point for improving the tinymalloc implementation :-)
this is why I invite you to contribute to the code.</p>
<p><a href="https://github.com/sibellavia/tinymalloc">the tinymalloc repository is on github</a> and the indications to contribute are really essential (bcos I want to remember that the project is just for fun!):</p>
<ul>
<li>use 2 spaces for indentation</li>
<li>add inline comments where possible</li>
<li>write unit tests for new features</li>
<li>always check for buffer overflows and memory leaks</li>
</ul>
<h2 id="resources">resources</h2>
<p><a href="https://x.com/sibellavia/status/1823836940153839974"><img src="/images/tinymalloc.c/resources.png" alt="my X post with tinymalloc resources"></a></p>
<p><a href="https://x.com/sibellavia/status/1823836940153839974">I wrote a post on X</a> listing all the resources I studied that inspired me for tinymalloc. you can take a look.</p>
<p>thank you for reading this far! if you liked this blog post, <a href="https://x.com/sibellavia">consider following me on X.</a></p>

</article>

  </main>
  <footer>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        throwOnError : false
      });
    });
</script>



  </footer>
</body>
</html>
